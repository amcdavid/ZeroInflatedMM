## Conditional MLE vs Conditional Regression
```{r load2, cache=FALSE,error=FALSE}

library(reshape2)
library(ggplot2)
#library(directlabels)
library(plyr)
library(parallel)
library(data.table)
library(stringr)
#library(sampleSelection)
library(rstan)
options(mc.cores=3)

prefix <- 'tobit'
opts_chunk$set(cache=TRUE, autodep=TRUE, echo=FALSE, dev='png', cache.path=sprintf('cache/%s__', prefix), fig.path=sprintf('figure/%s__', prefix), error=FALSE, warning=FALSE)
lausanne <- readRDS('data/lausanne_pd1cxcr5/fl1.rds')
ra <-  readRDS('~/Desktop/dropbox_work_tmp/sca_downsample.rds')
ngo <- scale(rowMeans(lausanne>0))
freq <- colMeans(lausanne>0)

```

```{r setupData}
#idx <- sort(sample(nrow(lausanne), 200)) #1:nrow(lausanne) #
idx <- 1:nrow(lausanne)
dat <- lausanne[idx,1:6]
N <- nrow(dat)
G <- ncol(dat)

v <- 1*(dat>0)
IposArr <- apply(v==1, 2, which)
Ipos <- unlist(IposArr)
IposGI <- c(1, cumsum(sapply(IposArr, length))+1)
y <- dat[v==1]
x <- cbind(1, ngo[idx])

all.equal(y[IposGI[1]:(IposGI[2]-1)], dat[v[,1]==1,1], check.attributes=F)
all.equal(y[IposGI[4]:(IposGI[5]-1)], dat[v[,4]==1,4], check.attributes=F)
all.equal(y[IposGI[G]:(IposGI[G+1]-1)], dat[v[,G]==1,G], check.attributes=F)

```


```{r stanZero}
standat <- list(N=nrow(dat), Tf=ncol(x), G=G, NposG=length(Ipos), x=x, v=t(v),
                Ipos=Ipos, IposGI=IposGI, y=y, marginal=0)
m <- stan_model('zeroModels.stan')
fit1 <- stan(file="zeroModels.stan", data=standat, iter=2000, chains=3, cores=3)

#o <- optimizing(m, data=standat)

#write a data.table with a column for the parameter, then extract i, j and value
makeParTable <- function(fit, pname, rename){
    pdim <- fit@par_dims[[pname]]
    if(missing(rename)) rename <- pname
    if(length(pdim)>0){
        namesMaybe <- c('i', 'j', 'k', 'l')
        if(length(pdim)<5){
            names(pdim) <- namesMaybe[seq_along(pdim)]
        } else{
            stop('Parameter dimension  rank must be < 5')
        }
        pgrid <- do.call(expand.grid, lapply(rev(pdim), seq_len))
        
    }
    nchains <- length(fit@inits)
    postMean <- get_posterior_mean(fit, pname)[,nchains+1]
    data.table(pgrid, value=postMean, rename)
}

pt <- rbind(makeParTable(fit2, 'betaM_Tf_G', 'betaM'),
            makeParTable(fit2, 'betaD_Tf_G', 'betaD'))

dc <- dcast.data.table(pt, i+j ~ rename)
ggplot(dc, aes(x=betaD, y=betaM))+geom_text(aes(label=i)) + geom_smooth() + facet_wrap(~j, scales='free')

```

```{r stanHeckit}
standat <- list(N=nrow(dat), Tf=ncol(x), G=G, NposG=length(Ipos), x=x, v=t(v),
                Ipos=Ipos, IposGI=IposGI, y=y)
m <- stan_model('tobit2.stan')
fit2 <- stan('tobit2.stan', data=standat, iter=2000, chains=3, cores=3)


```


```{r stanDat}
x <- cbind(ngo[idx])
xr <- matrix(1, nrow=length(idx))
ids <- str_extract(rownames(dat), '(AVIB|CNA) [0-9]+')
Nr <- length(unique(ids))
rr <- as.numeric(factor(ids))


standat <- list(N=nrow(dat), Tf=ncol(x), Tr=ncol(xr),  Nr=Nr, rr=rr, x=x, xr=xr, y=t(dat), v=t(1*(dat>0)))
m <- stan_model('tobit.stan')
## This seems to be quadratic (?) in the number of samples, but linear in genes
fit1 <- stan(file="tobit.stan", data=standat, iter=2000, chains=3, cores=3, control=list(adapt_delta=.9))

## Need a boundary-avoiding prior, variance component hyper-params getting pushed to zero
fit1 <- optimizing(m, data=standat, iter=2e4)

print(fit1)
pairs(fit1, pars=c('gamaD_Tr', 'gambD_Tr'))
pairs(fit1, pars='kappa_Tr_G')
```

```{r}
tobitEx <- expand.grid(rho=c(-.8, 0, .8), mu1=c(-2, 0, 5), mu2=c(5, 10, 15), x=seq(0, 20, by=.1))
tobitEx$value <- NA
pTobit2 <- function(x, rho, mu1, mu2){
    if(x>0)
        pnorm((mu1 + rho*(x-mu2))/sqrt(1-rho^2))*dnorm(x-mu2)
    else 0
    }

for(i in seq_len(nrow(tobitEx))){
    tii <- tobitEx[i,]
    tobitEx[i,'value'] <- pTobit2(tii$x, tii$rho, tii$mu1, tii$mu2)
    }

tobitEx <- ddply(tobitEx, ~rho+mu1+mu2, function(dd){
    norm <- sum(dd$value)
    #dd$value <- dd$value/norm
    dd$norm <- norm/10
    dd
    })


ggplot(tobitEx, aes(x=x, y=value, col=factor(mu1)))+geom_line()+facet_grid(rho ~ mu2, scales='free_y')
ggplot(tobitEx, aes(y=norm, x=mu1, col=factor(mu1)))+geom_point() +facet_grid(rho ~ mu2, scales='free_y')

```

```{r}
lausanneNgo <- data.table(lausanne, ngo)
datM <- melt.data.table(lausanneNgo, id.vars='ngo')
datM[,valueI:=value>0]

tt <- dlply(datM, ~variable, function(x){
    Sh <- tryCatch(selection(valueI~ngo, value~ngo, data=x, method='ml'), error=function(e) selection(valueI~1, value~ngo, data=x, method='2step'))
    Sd <- glm(valueI~ngo, family=binomial(link='probit'), data=x)
    Sc <- lm(value~ngo, subset=valueI>0, data=x)
    list(gene=as.character(x$variable[1]), coefh=coef(Sh), vcovh=sqrt(diag(vcov(Sh))), coefP=coef(Sd), coefC=coef(Sc), Ni=sum(x$valueI))
    })

ss <- selection(valueI ~ variable + ngo, value~variable + ngo, data=datM, method='ml')

rhoest <- ldply(tt, function(li) c(rho=li$coefh['rho'], se=li$vcovh['rho'], Ni=li$Ni))
rhoest[is.na(rhoest[,'se.rho']),'se.rho'] <- median(rhoest[!is.na(rhoest[,'se.rho']),'se.rho'])
ggplot(rhoest, aes(x=reorder(variable, rho.rho), y=rho.rho, ymin=rho.rho-se.rho, ymax=rho.rho+se.rho, fill=Ni))+geom_crossbar() + coord_flip()
```
